/* Продолжите программу. Необходимо из массива ar в обратном порядке (идя от последнего записанного значения к первому)
скопировать прочитанные данные в массив marks (копирование выполнять от первого элемента к последнему),
не выходя за пределы массива marks. То есть, в случае достижения последнего элемента массива marks, останавливать процедуру копирования.
Вывести в консоль значения массива marks (от первого до последнего скопированного элемента) в одну строчку через пробел.*/

#include <stdio.h>

int main(void)
{
    short ar[10], marks[5];
    size_t count = 0;
    size_t sz_ar = sizeof(ar) / sizeof(*ar);

    while(count < sz_ar && scanf("%hd", &ar[count]) == 1)
        count++;

    // Заданная логика для копирования данных в обратном порядке
    size_t i;
    size_t marks_count = (count < 5) ? count : 5; // Определение количества элементов для копирования
    for (i = 0; i < marks_count; ++i) {
        marks[i] = ar[count - 1 - i]; // Копирование в обратном порядке
    }

    // Вывод значений массива marks
    for (i = 0; i < marks_count; ++i) {
        printf("%hd ", marks[i]);
    }
    printf("\n");

    return 0;
}
